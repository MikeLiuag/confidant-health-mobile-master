import React from 'react';
import PushNotification from 'react-native-push-notification';

import {Alert, Platform} from "react-native";
import OneSignal from 'react-native-onesignal';
import AuthStore from '../utilities/AuthStore';
import {ONESIGNAL_APP_ID, VIDEO_CALL} from '../constants/CommonConstants';
import NavigationService from '../services/NavigationService';
import {Screens} from '../constants/Screens';
import {CONNECTION_TYPES, getAvatar, isTelehealthConfigured, NOTIFICATION_TYPES, SocketClient,} from "ch-mobile-shared";
import PushNotificationIOS from '@react-native-community/push-notification-ios';
import {connectReduxState} from '../redux/modules';
import {APPOINTMENTS_FETCH} from '../redux/modules/appointments/actions';
import {FETCH_ASSIGNED_CONTENT} from '../redux/modules/educational-content/actions';
import {GET_CONNECTIONS_SILENT, GET_SPECIFIC_CONNECTION, GROUP_CALL_ACTIVE} from '../redux/modules/connections/actions';
import moment from "moment";

/**
 * Component to listen to the push notifications
 *
 * @class PushNotificationListeners
 * @extends React.PureComponent
 */
class PushNotificationListeners extends React.PureComponent {

    static dispatchToRedux = null;
    static notificationCallbacks = {
        'CONTENT_ASSIGNED': {},
    };

    constructor(props) {
        super(props);

        PushNotificationListeners.dispatchToRedux = this.props.dispatch;

    }

    static addNotificationCallback(type, key, cb) {
        console.log('Adding Notification callback for type ' + type + ' with key ' + key);
        const callbacks = PushNotificationListeners.notificationCallbacks[type];
        callbacks[key] = cb;
    }

    static removeNotificationCallback(type, key) {
        console.log('Removing Notification callback for type ' + type + ' with key ' + key);
        const callbacks = PushNotificationListeners.notificationCallbacks[type];
        delete callbacks[key];
    }


    static subscribeToOneSignal() {
        OneSignal.init(ONESIGNAL_APP_ID, {
            kOSSettingsKeyAutoPrompt: true,
            kOSSettingsKeyInFocusDisplayOption: 0,
        });
        console.log('OneSignal Init Successfully');
        OneSignal.addEventListener('received', PushNotificationListeners.onReceived);
        OneSignal.addEventListener('opened', PushNotificationListeners.onOpened);
        OneSignal.inFocusDisplaying(0);
    };


    static navigateToTelehealth(data) {
        isTelehealthConfigured().then(isConfigured => {
            NavigationService.navigateTo(!isConfigured ? Screens.TELEHEALTH_WELCOME : Screens.VIDEO_CALL, {
                provider: {
                    name: data.from.name,
                    userId: data.from.userId,
                },
                sessionId: data.sessionId,
                token: data.sessionToken,
                fromNotification: true,
            });
        });
    }

    static showIncomingAlert(data) {
        Alert.alert(
            'New Telehealth Session',
            data.from.name + ' wants to have a telesession with you',
            [
                {
                    text: 'Reject',
                    onPress: () => {
                        AuthStore.deleteIncomingSessionNotification().then(() => {
                            console.log('Deleted Temp Session Notification data');
                        });
                        const socket = SocketClient.getInstance().getConnectedSocket();
                        if (socket) {
                            socket.emit('tele-session-rejected', {
                                sessionId: data.sessionId,
                            });
                        }

                    },
                    style: 'cancel',
                },
                {
                    text: 'Accept & Join', onPress: () => {
                        AuthStore.deleteIncomingSessionNotification().then(() => {
                            console.log('Deleted Temp Session Notification data');
                        });
                        PushNotificationListeners.navigateToTelehealth(data);
                    },
                },
            ],
            {cancelable: false},
        );

    }

    static showLocalNotification = (title, message, data, isOngoing) => {
        PushNotification.localNotification({
            //         /* Android Only Properties */
            id: '0', // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
            ticker: 'My Notification Ticker', // (optional)
            autoCancel: true, // (optional) default: true
            largeIcon: 'ic_launcher_foreground', // (optional) default: "ic_launcher"
            smallIcon: 'ic_launcher_foreground', // (optional) default: "ic_notification" with fallback for "ic_launcher"
            bigText: '', // (optional) default: "message" prop
            subText: null, // (optional) default: none
            vibration: 300, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
            ongoing: isOngoing, // (optional) set whether this is an "ongoing" notification
            priority: 'high', // (optional) set notification priority, default: high
            visibility: 'private', // (optional) set notification visibility, default: private
            importance: 'high', // (optional) set notification importance, default: high
            data,
            //
            //         /* iOS only properties */
            userInfo: {id: '123', ...data},
            //         /* iOS and Android properties */
            title: title, // (optional)
            message: message,
            playSound: true, // (optional) default: true
            // actions: '["Yes", "No"]',  // (Android only) See the doc for notification actions to know more
        });
    };


    /**
     * @function navigateToRespectiveScreen
     * @description This method is used navigate to respective screen ( Deep Linking )
     * @params notification
     */

    static navigateToRespectiveScreen = (notification) => {
        console.log("navigate to respective screen", notification);
        if (notification?.data?.metadata || notification?.data?.eventMeta) {
            if (notification.data.notificationType === NOTIFICATION_TYPES.GROUP_MESSAGE_RECEIVED) {
                NavigationService.navigateTo(Screens.LIVE_CHAT_WINDOW_SCREEN, {
                    connection: {
                        ...notification?.data?.metadata,
                        connectionId: notification.data?.metadata?.channelUrl,
                        profilePicture: getAvatar(notification.data.metadata.channelUrl)
                    },
                    fromNotification: true
                });
            } else if (notification.data.notificationType === NOTIFICATION_TYPES.CHAT_MESSAGE_RECEIVED) {
                NavigationService.navigateTo(Screens.LIVE_CHAT_WINDOW_SCREEN, {
                    connection: {
                        ...notification?.data?.metadata,
                        connectionId: notification.data?.metadata?.senderId,
                        profilePicture: getAvatar(notification.data.metadata.senderId)
                    },
                    fromNotification: true
                });
            } else if (notification.data.notificationType === NOTIFICATION_TYPES.GROUP_CALL_STARTED) {
                NavigationService.navigateTo(Screens.GROUP_CALL_SCREEN, {
                    connection: {
                        ...notification.data.metadata,
                        channelUrl: notification.data?.eventMeta?.channelUrl,
                    },
                    fromNotification: true
                });
            } else if (notification.data.notificationType === NOTIFICATION_TYPES.INCOMING_TELESESSION) {
                NavigationService.navigateTo(Screens.APPOINTMENT_DETAILS_SCREEN, {
                    appointment: {
                        ...notification?.data?.metadata,
                    },
                    fromNotification: true
                });
            } else if (notification.data.notificationType === NOTIFICATION_TYPES.APPOINTMENT_REQUESTED ||
                notification.data.notificationType === NOTIFICATION_TYPES.APPOINTMENT_CONFIRMED ||
                notification.data.notificationType === NOTIFICATION_TYPES.APPOINTMENT_REMINDER ||
                notification.data.notificationType === NOTIFICATION_TYPES.APPOINTMENT_PRE_REMINDER
            ) {
                NavigationService.navigateTo(Screens.APPOINTMENT_DETAILS_SCREEN, {
                    appointment: {
                        ...notification?.data?.eventMeta,
                        participantId: notification?.data?.eventMeta?.memberId,
                        participantName: notification?.data?.eventMeta?.memberName,
                        startText: moment(notification?.data?.eventMeta?.startTime).format("h:mm a"),
                        endText: moment(notification?.data?.eventMeta?.endTime).format("h:mm a"),
                        date: moment(notification?.data?.eventMeta?.startTime).format("DD"),
                        month: moment(notification?.data?.eventMeta?.startTime).format("MMMM"),
                        year: moment(notification?.data?.eventMeta?.startTime).format("YYYY"),
                        lastModified: '',
                        serviceDuration: notification?.data?.eventMeta?.serviceDuration
                    },
                    fromNotification: true
                });
            } else if (notification.data.notificationType === NOTIFICATION_TYPES.GROUP_CREATED) {
                NavigationService.navigateTo(Screens.GROUP_DETAIL_SCREEN, {
                    connection: {
                        ...notification?.data?.metadata,
                        connectionId: notification.data?.metadata?.channelUrl,
                        profilePicture: getAvatar(notification.data.metadata.channelUrl)
                    },
                    fromNotification: true
                });
            } else if (notification.data.notificationType === NOTIFICATION_TYPES.GROUP_MEMBER_ADDED ||
                notification.data.notificationType === NOTIFICATION_TYPES.GROUP_MEMBER_LEFT ||
                notification.data.notificationType === NOTIFICATION_TYPES.GROUP_MEMBER_REMOVED) {
                NavigationService.navigateTo(Screens.GROUP_DETAIL_SCREEN, {
                    connection: {
                        ...notification?.data?.metadata,
                        connectionId: notification.data?.metadata?.channelUrl,
                        profilePicture: getAvatar(notification.data.metadata?.channelUrl)
                    },
                });
            } else if (notification.data.notificationType === NOTIFICATION_TYPES.NEW_CONNECTION_REQUESTED) {
                if (notification.data?.metadata?.connectionPending.type === CONNECTION_TYPES.PATIENT) {
                    NavigationService.navigateTo(Screens.MEMBER_PROFILE_SCREEN, {
                        ...notification.data?.metadata?.connectionPending,
                        userId: notification.data?.metadata?.connectionPending?.connectionId,
                        fromNotification: true
                    })
                } else if (notification.data?.metadata?.connectionPending?.type === CONNECTION_TYPES.PRACTITIONER || connection.type === CONNECTION_TYPES.MATCH_MAKER) {
                    NavigationService.navigateTo(Screens.PROVIDER_DETAIL_SCREEN, {
                        provider: {
                            ...notification?.data?.metadata?.connectionPending,
                            userId: notification.data?.metadata?.connectionPending?.connectionId
                        },
                        providerId: notification?.data?.metadata?.connectionPending?.connectionId,
                        type: notification?.data?.metadata?.connectionPending?.type,
                    })
                }
            } else {
                notification.finish(PushNotificationIOS.FetchResult.NoData);
            }
        } else {
            notification.finish(PushNotificationIOS.FetchResult.NoData);
        }
    }

    static attachLocalListeners = (socket) => {
        PushNotification.configure({
            permissions: {
                alert: true,
                badge: true,
                sound: true,
            },
            onNotification: function (notification) {
                // process the notification

                // required on iOS only (see fetchCompletionHandler docs: https://github.com/react-native-community/react-native-push-notification-ios)
                //notification.finish(PushNotificationIOS.FetchResult.NoData);
                PushNotificationListeners.navigateToRespectiveScreen(notification)

            },
            popInitialNotification: true,
            requestPermissions: Platform.OS === 'ios'
        });
        console.log('Listeners attached');
        socket.on('incomingTelesession', data => {
            PushNotificationListeners.showLocalNotification(data.from.name + ' ' + 'arrived for session',
                data.from.name + ' ' + 'has arrived and waiting for you to join the scheduled session',
                {...data, notificationType: 'VIDEO_CALL'}, false);
        });
        socket.on('content-assigned', data => {
            console.log('New Content Assigned');
            PushNotificationListeners.showLocalNotification('New Education Content Assigned', data.assignedBy + ' assigned a new education article to you.', {
                ...data,
                notificationType: 'CONTENT_ASSIGNED',
            }, false);
        });

        socket.on('reminder_notification', data => {
            console.log('Reminder notification received');
            PushNotificationListeners.showLocalNotification('Reminder Notification', data.description, {
                ...data,
                notificationType: 'reminder_notification',
            }, false);
        });

        socket.on('group-call-check-response', data => {
            if (PushNotificationListeners.dispatchToRedux) {
                const {channelUrl, active} = data;
                PushNotificationListeners.dispatchToRedux({
                    type: GROUP_CALL_ACTIVE,
                    payload: {
                        channelUrl,
                        active,
                    },
                });
            }
        });

        socket.on('app-notification-received', data => {
            console.log('Got a live app notification');

            let shouldShowNotification = true;
            if (data.notificationType === 'CHAT_MESSAGE_RECEIVED' || data.notificationType === 'GROUP_MESSAGE_RECEIVED') {
                const currentNavParams = NavigationService.getCurrentRouteParams();
                if (currentNavParams.routeName === Screens.LIVE_CHAT_WINDOW_SCREEN) {
                    const {connection} = currentNavParams.params;
                    if (data.notificationType === 'CHAT_MESSAGE_RECEIVED' && data.metadata.senderId === connection.connectionId) {
                        console.log('Chat open for contact. Ignoring local notification display');
                        shouldShowNotification = false;
                    } else if (data.notificationType === 'GROUP_MESSAGE_RECEIVED' && data.metadata.channelUrl === connection.connectionId) {
                        console.log('Chat open for group. Ignoring local notification display');
                        shouldShowNotification = false;
                    }
                }
            } else if (data.notificationType === 'CONVERSATION_ASSIGNED') {
                const currentNavParams = NavigationService.getCurrentRouteParams();
                if (currentNavParams.routeName === Screens.CHAT_INSTANCE) {
                    shouldShowNotification = false;
                }
            }
            PushNotificationListeners.dispatchNotificationActions(data.notificationType, data);
            if (shouldShowNotification) {
                PushNotificationListeners.showLocalNotification(data.title, data.subtitle, {
                    ...data,
                    notificationType: data.notificationType,
                }, false);
            }
        });
        socket.on('app-refresh-update', data => {
            if (data.shouldUpdateConnections) {
                if (PushNotificationListeners.dispatchToRedux) {
                    PushNotificationListeners.dispatchToRedux({
                        type: GET_CONNECTIONS_SILENT,
                    });
                }
            }
        });
    };

    static dispatchNotificationActions = (notificationType, data) => {
        console.log('Checking notificationType: ' + notificationType + ' for dispatch');
        switch (notificationType) {
            case 'APPOINTMENT_REQUESTED':
            case 'APPOINTMENT_NEEDS_ACTION':
            case 'APPOINTMENT_CONFIRMED':
            case 'APPOINTMENT_CANCELLED': {
                if (PushNotificationListeners.dispatchToRedux) {
                    PushNotificationListeners.dispatchToRedux({
                        type: APPOINTMENTS_FETCH,
                    });
                }
                break;
            }
            case 'CONTENT_ASSIGNED': {
                const callbacks = PushNotificationListeners.notificationCallbacks['CONTENT_ASSIGNED'];
                Object.keys(callbacks).forEach(key => {
                    callbacks[key]();
                });
                if (PushNotificationListeners.dispatchToRedux) {
                    console.log('Dispatching FETCH_ASSIGNED_CONTENT to redux');
                    PushNotificationListeners.dispatchToRedux({
                        type: FETCH_ASSIGNED_CONTENT,
                    });
                }


                break;
            }
            case 'CHAT_MESSAGE_RECEIVED': {
                if (PushNotificationListeners.dispatchToRedux) {
                    setTimeout(() => {
                        PushNotificationListeners.dispatchToRedux({
                            type: GET_SPECIFIC_CONNECTION,
                            payload: {
                                connectionId: data.metadata.senderId,
                            },
                        });
                    }, 2000);

                }
                break;
            }
            case 'GROUP_MESSAGE_RECEIVED': {
                if (PushNotificationListeners.dispatchToRedux) {
                    setTimeout(() => {
                        PushNotificationListeners.dispatchToRedux({
                            type: GET_SPECIFIC_CONNECTION,
                            payload: {
                                connectionId: data.metadata.channelUrl,
                            },
                        });
                    }, 2000);

                }
                break;
            }
            case 'CONVERSATION_ASSIGNED':
            case 'GROUP_CREATED': {
                if (PushNotificationListeners.dispatchToRedux) {
                    PushNotificationListeners.dispatchToRedux({
                        type: GET_CONNECTIONS_SILENT,
                    });
                }
                break;
            }
            default: {

            }
        }
    };

    static onReceived = (notification) => {
        console.log('OneSignal Notification received: ', notification);
    };

    static onOpened = (openResult) => {
        console.log('OneSignal Message: ', openResult.notification.payload.body);
        console.log('OneSignal Data: ', openResult.notification.payload.additionalData);
        console.log('OneSignal isActive: ', openResult.notification.isAppInFocus);
        console.log('OneSignal openResult: ', openResult);
    };

    render() {
        return this.props.children;
    }
}

export default connectReduxState()(PushNotificationListeners);
